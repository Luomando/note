// 编译预处理指令:#开头的是编译预处理指令（在程序编译之前对代码进行一定的处理，主要就是替换操作），不是C语言
#include <stdio.h>  //引入标准输入输出；h-head头文件
#include <string.h>  //引入字符串处理库
#include <stdbool.h>  //引入布尔类型，原生没有布尔类型
#include <stdlib.h>  //使用malloc需要这个头文件
#include "acllib.h"  //引入自己的头文件，用""

#define PI 3.14159  //定义一个宏；PI是名字，可在程序各个地方使用PI来表示3.14159；程序在编译预处理的时候就会把程序中所有的PI替换为3.14159；没有类型，就是很简单直接的替换操作
#define PI2 2*PI  //可以这样定义
#define PRT printf("%f\n", PI);\  //多行宏定义，行末用\表示这个宏还没结束，转到下行继续
            printf("%f\n", PI2)
#define cube(x) ((x)*(x)*(x))  //定义带参数的宏；如调用cube(5)实际上会替换为((5)*(5)*(5))；这么多括号的作用是：cube(i+2)==((i+2)*(i+2)*(i+2))如果没有括号，意思就完全不一样了，所以在定义带参数的宏的时候，每个参数都需要加上括号，并且外部有个大括号
__LINE__ __FILE__ __DATE__ __TIME__  //C内部的预定义宏，可以在程序中直接使用


void fn(int i,char a);  //函数可以声明，又叫函数原型，需要写在#include下面main()上面；如果未声明的函数则不能在那个函数代码之前调用这个函数，所以，如果想在任意地方调用函数最好进行函数声明；这里参数也可以不带名称，只带类型

int g=10;  //声明全局变量，类似JS，建议少用

int main(){  //主函数，程序从这个函数开始运行
    printf("Hello World");  //输出函数；就是来自stdio.h，在编译的时候会通过链接器合并；返回输出的字符数
    printf("%s%d\n","年龄",28 );  //%表示引导符，后面的字符表示期望的类型，s-string|d-decimal(十进制整数)|o-八进制|x-十六进制|i-int|f-float|lf-double|c-char|p-point(地址)
    char(1) int(4) float(4) double(8)  //C语言中各种各种类型占用的字节数，没有string，string实际上是多个char

    int price=0;  //定义一个变量；C99的可以定义在任何地方，ANSI C的必须定义在开头
    const int AMOUNT=100;  //定义一个常量
    scanf("price%d,%d");  //scanf()的作用是需要接收的输入，比如这样的格式在输入的时候就必须为 price10,20 这样的内容，必须完全匹配，否则出错
    scanf("%d",&price);  //输入函数：%d表示需要接收一个数字，若不是数字则会采用定义price变量时的初始值；&为地址符，和PHP的类似，因为这个函数中会进行对外部变量的修改，所以必须传入带地址符的参数才能实现；返回读了几个变量进来
    scanf("%d %d",&a,&b);  //在输入的时候可以一次性输入两个数，中间用空格隔开；也可以输入一个数，回车，再输入一个数
    printf("应找金额%d元\n",AMOUNT-price );  //运算操作，和别的语言一样，+-*/%
    printf("%d",5>3);  //输出1
    int a=0,b=0;  //不能使用int a=b=0;因为b不存在
    static int s=10;  //声明静态变量，和PHP的特性类似；是特殊的全局变量，只是不能被别的函数访问，拥有全局生存期局部作用域；输出地址和全局变量类似和普通变量不同，可以看出全局变量和普通变量保存位置不同，从而生存期不同；线程不安全，建议少用

    int i,j;
    j=i+10;
    printf("%d",j);  //注意，这里可能不会输出10，因为定义了一个变量，而这个变量在内存中没有初始化，如果它所在的位置有残留的垃圾，则会赋予垃圾的值。所以，在创建变量的时候最好赋予初始值！
    printf(j);  //错误！不能这样直接输出变量！

    printf("%f",10/3.0);  //要得到浮点数，进行运算的两个数中需要有一个为浮点数，如果这里是10/3则结果不正确，通常会直接舍弃掉小数部分

    if else else if  //和别的语言差不多，elseif不能连写

    switch case  //也和别的语言差不多，但只支持整型

    for while do while  //也和别的语言差不多

    ++ -- += -= *= /= %=  //也和别的语言差不多

    '' ""  //当定义char类型的时候只能使用''，字符使用""

    {
        int i=0;  //大括号定义一个块，这个块里的作用域是独立的，不会影响到外面的，可用于做调试等用
    }

    // 类型
    // 整数：二进制数
    char  short  int  long  long long
    int的大小和寄存器有关
    unsigned char c=255;  //使用unsigned表示无符号类型
    char c=012;  //八进制
    int i=0x12;  //十六进制
    (int)f;  //强制类型转换，当然不仅只有int，各种皆可
    注：现代计算机都为32位或64位，在读取数据的时候一次至少会读取32bit或64bit，而char,short这些类型虽然看似占用的空间更小，但实际上没啥意义，反而在取出32/64bit后还要转换为更小的类型，影响效率。所以，通常用int更好
    // 浮点数：非二进制数，编码的形式存在，运算的时候会把编码交给CPU专门解码的硬件计算
    float  double  long double
    %.7f  //要求输出小数位数为7位，原数字小数更多，则四舍五入
    12.0/0.0  //得到无穷大，但12/0报错，因为无穷大是用浮点数表示的
    fabs(f1-f2)<1e-8  //判断两个浮点数是否相等，不能用==，但可以通过相减后取绝对值，然后判断这个差值是否小于精度
    注：浮点数是离散型的，不是所有浮点数都能表达，比如一个数为0.0048，而这个数恰好不能表达，则会取出离他最近的能表达的那个浮点数，这就是浮点数的误差。double比float能表达的数更多，两个数间的距离就更小，但依然会有无法表达的数
    // 逻辑
    bool
    // 指针
    *p arr[]
    // 自定义类型
    // 枚举：内部就是int类型
    enum COLOR={RED,YELLOW,GREEN,NUMCOLORS};  //定义一个枚举，里面定义的元素的值是从0开始累加1，这里RED=0,YELLOW=1,GREEN=2；枚举是常量，主要用来定义名称方便使用辨识;NUMCOLORS通常会定义一个用于计数的元素，方便遍历这个枚举等，NUMCOLORS的值为3，就是枚举里实际有用的元素个数；枚举名COLOR也就是个自定义类型，但用处不大，主要是用里面的元素
    switch(c){
        case RED:  //里面的元素直接当常量使用即可。我们是想用0代表red，而0不易辨识，所以定义枚举RED来表示
            ...
        case YELLOW:
            ...
    }
    enum STATUS={OK=1,WRONG=3,WAIT=7,DIE};  //可以为每个元素自定义数字，但后面紧跟的元素就是前面的+1，DIE就是8
    // 结构：和数组相似，可以看作是关联数组，但结构的变量名字不是指针（地址），而是和普通变量类似，不同于数组变量；结构作为自定义类型说明具有类型的特征，可以作为函数参数传入，函数也可以返回某个结构类型等
    struct date  //使用struct声明一个结构类型
    {
        int month;
        int day;
        int year;
    };  //注意这里有个分号
    struct date today;  //定义一个结构变量today，类型为struct date
    today.month=06;  //为结构里的元素赋值
    today.day=04;
    today.year=2015;
    today=(struct date){01,01,2020};  //可以这样为结构里的元素赋值
    struct date today={10,20,2020};  //创建结构变量并赋值
    struct date today={.month=10,.year=2010};  //创建结构变量并为其中部分赋值，没赋值的默认为0
    struct date tomorrow;
    tomorrow=today;  //可以把一个结构变量赋给另一个结构变量，结构类型要相同，而数组不能这样赋值
    tomorrow.day=05;  //修改tomorrow的day不会影响到today的day
    struct *p=&today;  //将结构变量交给指针，注意由于结构不像数组那样是指针，所以需要加&
    (*p).month=12;  //*p就是today的数据，所以可以这样使用
    p->month=12;  //上面那句的简化写法；所以结构变量转换为指针后，指针能方便的操作结构变量内的元素（函数参数很有用），当然p不能为NULL
    struct  //匿名结构，用于不需要多次使用此结构的场合
    {
        int x;
        int y;
    }v1,v2;  //v1和v2是两个变量名，这两个变量就是这个匿名结构类型；因为是匿名结构，所以后面就不能像上面那样定义新的变量为这个结构
    v1.x=1;
    v1.y=5;
    v2.x=10;
    v2.y=6;
    struct day{  //这样是即定义了结构类型，同时创建了结构变量
        ...
    }today;
    int numberOfDays(struct date d){  //函数接收结构参数
        ...
    }
    struct date dates[]={{4,5,2010},{8,10,2020}};  //定义结构数组：外层是数组，里层是结构
    // 联合：主要当作工具使用，用于文件操作读写的中间媒介
    union AnElt{  //定义的形式和struct类似，其它定义方式也和struct相同
        int i;  //i和c占用的是相同的内存空间，但是由于类型不同，所以得到的数据形式也不同，比如这里i是1234
        char c[sizeof(int)];  //这样定义时，c的每个元素保存的是i这个整数内部的各个字节(形如04 D2 00 00)，然后用于文件读写操作
    }elt1,elt2;
    // typedef定义别名：提高可读性和易用性，可以将typedef和别名中间的很长的代码定义为一个别名，方便使用
    typedef int Length;  //为int类型定义别名Length，这个Length功能和int相同
    typedef struct ADate{
        ...
    } Date;  //简化了结构的名字，Date就能表示整个结构了
    typedef struct {  //使用typedef定义结构，简化结构使用
        ...
    } Date;  //定义匿名结构类型的时候使用typedef给一个别名，这个别名也就是整个匿名结构类型的名字了，也就让这个匿名结构类型有了名字
    Date today;  //创建这个结构类型的结构变量就更简单，上面那个需要使用struct ADate today

    // 数组
    int num[100];  //定义一个长度100的数组，不能int[100] num这样定义，JAVA可以；编译和运行环境通常不会检查数组是否越界，会在程序运行的时候产生崩溃等错误
    int num[]={1,2,3,4,5,6,7};  //定义数组并赋值，数组的长度就是赋值个数
    int num[4]={1};  //数组的长度是4，存储的数据为1,0,0,0
    int num[10]={[1]=2,[5]=4,7};  //可以为指定位置赋值，别的位置为0；结果是0,2,0,0,0,4,7,0,0,0,0
    int a[i];  //数组长度可由变量确定
    x int a[];  //错误！没有指定数组长度
    int num[3][5];  //定义一个二维数组；其它方法和一位数组差不多
    char a[][5]={'123','abc','zxcv'};  //这里实际上是a[3][5]，字符串就是个char类型数组，所以这里是个二维数组
    int a[][4]={{1,2,3},{4,5,6},{7,8,9,0}};  //二维数组第二维必须指定长度
    int m[][3] = {1,4,7,2,5,8,3,6,9,};  //这样声明，因为每例是3个，所以会自动把3个作为一组分给每例，等同于{{1,4,7},{2,5,8},{3,6,9}}
    num[0]=1;  //赋值和取值与别的语言差不多
    int length=sizeof(num)/sizeof(num[0]);  //sizeof()取得某个类型或变量占用的字节数，再除以每个元素占用的字节数就是长度
    x int num2[]=num;  //禁止！数组不能赋值给另一个数组或变量；只能遍历赋值

    // 字符串
    char c='a';  //一般的char类型只能保存一个字符，并且只能用单引号，长度为1字节，每个字符都可以转换为一个整数，参见ASC
    char s[]={'h','e','l','l','o','\0'};  //定义一个字符串hello；注意最后一个'\0'，只有加上这个才是定义字符串，标识字符串的结束；所以，一个字符串的长度为看到的长度+1
    char s[]="hello";  //直接定义一个字符串，效果和上面一样；编译器会帮你变成上面那样的字符数组
    char str1[8];
    char str2[9];
    printf("123""456");  //不需要使用连接符直接输出
    scanf("%7s",str1);  //使用scanf()读取用户输入，%s表示字符串，中间加个7表示最多读取7个字符，超出的会抛弃；当然这里不能写%8s，因为str定义的长度为8，也就最多只能接收7个长度的字符串；str也不用加&，因为数组就是个指针
    scanf("%7s%8s",str1,str2);  //这里一次性输入的字符串超过7个，多余的会自动给str2
    intc=getchar()  //从标准输入（终端shell里）读取一个字符，EOF返回-1；shell终端里ctrl+d结束输入返回-1
    putchar(c)  //输出一个字符，EOF返回-1
    注：关于越界问题，这里scanf("%9s",str1);可以写超出数组长度的大小，而且有可能能正常接收这么多(9)个长度的字符，但是要避免这种情况的发生。数组越界可读可写，而且可以向前越界也可以向后越界，只不过不对读写造成的任何后果负责。
    // 字符串处理库string.h的函数
    strlen(const char *s);  //返回字符串长度，不包含结尾的"\0"；
    strcmp(const char *s1,const char *s2);  //比较两个字符串大小（逐一字符比较），全相等返回0，不相等返回比较位置s1-s2的差值
    strcpy(char *restrict dst,const char *restrict src);  //复制字符串；将src复制到dst的空间，需要dst有足够的空间；restrict表示源字符串的内存空间和目标字符串的内存空间不能重叠
    strncpy(char *restrict dst,const char *restrict src,int n);  //安全复制字符串；n为最多复制多少个字符
    strcat(char *restrict s1,const char *restrict s2);  //字符串连接；将s2接到s1后面，需要s1有足够的空间
    strncat(char *restrict s1,const char *restrict s2,int n);  //安全字符串连接；n为最多连接多少个字符
    strchr(const char *s,char c);  //在s中寻找c第一次出现的位置，成功返回一个指向c的指针，失败返回null
    strstr(const char *s1,const char *s2);  //字符串中寻找另一个字符串
    strcasestr(const char *s1,const char *s2)  //忽略大小写查找字符串
    ...



    // 地址
    int i=10;
    int p=(int)&i;  //使用&取得变量的地址；(int)类型强制转换；现在p和i都指向同一个地址
    printf("0x%d\n", p);  //直接输出p即&i
    printf("%p\n", &i);  //使用%p输出地址；这两个输出的结果在32位架构中一样，64位架构中不一样，64位中%p输出的结果更大为16位
    x printf("%p\n", i);  //错误！%p需要接收的是一个地址，这里虽然能通过编译运行，但输出的是000000000000000A（i=10）
    int a[10];
    printf("%p\n", a);  //没用&符，也能正常输出；说明数组就是一个指针，保存的是一个地址（数组变量是特殊的指针）
    printf("%p\n", &a);
    printf("%p\n", &a[0]);  //前3个输出相同的地址
    printf("%p\n", &a[1]);  //输出&a[0]的地址+4的值；因为一个int是4个字节



    // 指针：保存地址的变量；用普通类型变量比如int保存地址不靠谱，因为不同架构是不同的地址，所以有了指针
    int i=10;
    int j=20;
    int *p=&i;  //使用*p创建一个指针p（p是指针，*p这个整体是p指针指向地址的具体数据，两个可以分开使用）；指针保存的是地址，所以&i前面的&不能少；把一个地址赋值给指针，编译器不会出现警告，而上面的int p=(int)&i;会出件警告
    int* p=&i;  //*可以挨着int也可以挨着p，是一样的
    x int *p=i;  //错误！这样写虽能通过编译运行，但这个指针的值就是10，和普通变量没什么区别，所以用指针来保存变量或一个值没有任何意义
    int *p=NULL;  //创建指针的时候，如果没有明确指向则赋值NULL或0
    x int *p=10;  //错误！当*p没有自定义指向位置的时候不能将非地址的值赋给它，因为这时候*p没赋值，但它是个指针，它占用的那个空间可能有残留的内容，而这个内容恰好又指向另一处数据，这时就会出现问题！
    p=&j;  //把另一个地址赋值给指针
    printf("%p\n", p);  //p是个指针，使用%p就能输出这个指针的地址
    printf("%p\n", p+1);  //指针+1，是要把指针指向下一个数据，所以并不是在指针的值上+1，而是加上这个指针所指位置占用的空间，比如指向的char就+1，指向的int就+4，这样指针才会指向下一个数据的位置
    printf("%d", *p);  //把*p作为一个整体，得到的就是p地址的数据，这里输出10
    int fn(int *p){  //函数接收指针（地址）的参数需要这样写，其实不仅接收了指针，也同时接收了指针指向的数据；就像接收个数组，也同时接收了数组内的数据
        ...  //里面操作接收到的指针，就会对传入参数的外部变量产生影响
        int k=*p;  //将指针p指向的数据赋值给变量
        *p=k+1;  //修改指针p指向的数据，也就会修改传入参数的那个地址的变量的数据
    }
    int *p=&i;
    void *q=(void*)p;  //指针也能强制类型转换，void表示这个指针暂时不知道指向什么类型
    fn(&i);  //调用的时候就需要传入参数的地址
    char **a;  //指向指针的指针；a是一个指针，指向另一个指针，那个指针指向一个字符(串)
    int *a=(int*)malloc(n*sizeof(int));  //malloc()的作用是申请一段内存，参数是字节数，返回是void*类型，申请失败返回0或null；这里我们要申请n个int的内存就该这样计算
    x a++;  //错误！不能修改申请的内存的指针指向，这样就无法使用free()释放这段内存了
    free(a);  //free(指针)，释放这个指针所指的内存空间；当申请的这段内容使用完后，用free()释放；有个malloc()就应该有个对应的free()只是这个free()的使用时机不同
    x free(&i);  //错误！free()只能释放malloc()申请的内存，或没分配内存即为null的指针

    // 数组与指针的关系：数组变量是特殊的指针；可以想象为数组是一个扩展了更多信息的指针的子类，当它传递给函数就向上转型为指针失去了那些东西了
    int a[5]={1,2,3,4,5};
    sizeof(a);  //在这里sizeof()会计算数组中所有元素的长度之和，一个int为4，所以这里是20；数组会保留size信息，但当它作为指针传递的时候会退化失去size信息，所以作为参数传递给函数，函数中无法取得数组的长度，只能取得一个地址的长度
    sizeof(*a);  //得到4，也就是一个int的大小。数组名是一个指针，那么a就是一个指针，指向数组的第一个元素的地址，*表示取指针对应地址的内容，那么*a就是取这个数组的第一个元素内容，就是一个int，于是就是4
    printf("%p\n", a);  //数组是特殊的指针，所以可以直接输出这个数组的地址
    printf("%p\n", &a[0]);  //数组中的元素就不是指针了，需要使用&
    int *p=a;  //把数组交给一个指针，这个指针会指向数组的开头，就是第一个元素
    printf("%d",*(p+1));  //p+1后指针就会指向下一个元素，p+n==a[n]
    int i=1;
    int *p=&i;
    printf("%d\n", *p);  //输出1，不解释
    printf("%d\n", p[0]);  //也输出1！因为指针也可以想象成一个特殊数组，我们取出指针中的第0个数据，就是它的实际数据；这里如果要取出p[1],p[2]等，可能不会报错，但是会取出别的内存地址的数据
    p[0]<===>a[0]  //所以，在某种意义上说，指针p[0]和数组a[0]是相通的
    char a[5][3]; char *a[5];  //这两种表达式的不同：第一种a[0]是一个有3个字符的空间装着a[0]a[1]a[2]；第二种a[0]是char*，是一个指针指向另一个字符(串)地址
    x int b[]=a;  //错误！不能将一个数组赋值给另一个数组。因为创建数组实际上是创建一个常量指针(int * const b)，这个指针所指的地址是不能改变的。而这里把一个数组赋值给另一个数组，实际上就是把一个指针赋值给另一个指针，试图改变b的地址，所以报错
    void fn(int a[]){
        sizeof(a);  //函数中不能对接收到的数组用sizeof()来取长度！因为数组的传递是指针（地址）的传递，这里接收到的是个地址，而地址的长度是固定的，比如32位的就是4个字节
    }
    void fn(int *a){  //接收数组用指针的方式和a[]数组的方式结果完全相同
        sizeof(a);  //得到一个指针的大小
    }

    // 文件输入输出
    FILE *fp=fopen("test.in","r");  //使用fopen()打开一个文件，返回包含这个文件信息的指针；失败返回NULL；FILE类型是stdio.h中的
    int num;
    fscanf(fp,"%d",&num);  //读取文件中的整形保存到num变量中
    fread()
    fwrite()
    fseek()
    fclose(fp);  //关闭文件


    return 0;  //因为主函数定义的返回值是int，虽然我们不需要返回什么，但是也得返回个数字
    
}

// 函数
int main(int argc,char const *argv[]){}  //main函数实际上接收了这两个参数，主要通过命令行执行程序来体现：argc是argv[]数组的长度，argv[]是执行这个程序的命令的字符串数组；如$ ./a.out 123 456这样来执行a.out，argv[0]=./a.out,argv[1]=123,argv[2]=456
void fn(int i,char a){  //定义一个自己的函数，如果写在在main()下面，而main()中要调用，则需要在main()上面进行函数声明；接收参数只有char没有string类型
    ...
}
fn(12,20);  //调用函数的时候，传入的参数会进行类型的自动转换
int search(int key,int num[],int length){  //函数里要用到数组的长度，则必须从外面传进这个长度值，无法在函数内使用sizeof()计算数组的长度
    int ret=-1;
    int i;
    for (int i = 0; i < length; i++)
    {
        if (num[i]==key)
        {
            ret=i;
            break;
        }
    }
    return ret;
}
// 将函数赋给指针
void f(){
    printf("f()\n");
}
int main(){
    f();
    void (*p)()=f;  //这里就将一个函数交给一个指针，注意必须加括号
    (*p)();
    return 0;
}

// 项目
C程序以项目的形式存在，一个项目中可以有多个.c文件，相互之间不需要使用类似include这样的关键词引入，编译器在编译的时候会自动将多个相关联的.c文件进行关联编译。
比如一个函数要从主文件中分离出来，就新建一个.c文件，把它剪切到这个文件中，与主文件同项目同目录即可
注：在主文件中必须进行函数声明，否则可能出现意外情况；一般的做法是每个.c文件都有个对应的同名.h文件，将函数声明（原型）和这个.c文件用到的全局变量声明放进去，然后用#include引入.h文件
//头文件：.h的文件就是头文件，约定俗成只有声明才放到头文件中，否则可能会出现问题
void fn(int i,char a);  //函数声明
extern int g;  //在.h头文件中声明全局变量的方式；int g是定义变量，extern int g是声明变量，声明不产生代码而定义要产生
typedef struct s{...}  //声明结构；但是相同的结构是不能重复声明的，也就是说如果引入的不同的.h文件中，有着相同的结构声明则会出错
// 标准头文件格式
#ifndef __LIST__HEAD__  //如果这个头文件未定义
#define __LIST__HEAD__  //则定义这个头文件；这样在合理的定义下能避免结构声明重复导致错误的问题
    进行各种声明
#endif