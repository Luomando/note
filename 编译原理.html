编译器核心功能：
源代码（C,Java等）—>编译器（静态计算：只翻译不执行）—>目标程序（x86,bytecode等：不同语言的源代码生产的目标代码也不同，最后生成一个可执行程序即目标程序）—>计算机（PC,JVM等：对目标程序进行动态运算并执行）—>结果
解释器：
源代码—>解释器—>结果（不会生成可执行程序，直接输出结果）

模块化：编译器内部具有非常模块化的高层结构，从而简化编译器的开发，在编译过程中具有多个阶段组成的流水线模式
前端模块：将输入部分作为一个模块，又可以更细分为词法分析模块、语法分析模块等
后端模块：将输出部分作为一个模块，又可以更细分为指令生成模块、指令优化模块等
一种没有优化的编译器结构：
源代码（字符序列）—>词法分析（记号序列）—>语法分析（抽象语法树）—>语义分析（中间代码）—>代码生成（目标代码）

指令：代码在CPU上运行会先通过编译等翻译为一条条的指令，CPU的运行速度越高，每秒运行的指令也就越多，通常的计算机CPU能达到上亿条指令每秒的运算速度

简单的编译例子：
源代码：1+2+3
通过词法语法分析得到二叉树结构：
    +
  +   3
1   2
以后续遍历（从下往上）的方式进行编译，使用编译指令push和add：
push(1)->push(2)->push(+)：当push到add(+)指令的时候就会从栈中取出两个数进行相加1+2得到3，然后push(3)到栈中，继续编译
push(3)->push(+)：再次读到add指令，又从栈中读取两个数相加3+3得到6，然后push(6)，编译完毕。
这个例子编译完毕后，就是一个6
*由此就可以看出编译和解释的性能差距，编译后的程序在运行的时候就直接运行6；而解释器就是将源代码1+2+3来运行

<!-- 词法分析 -->
将源代码作为字符流一个一个字符读入进行分析，然后翻译成自己能理解的语法格式。字符流到记号流的转换。
字符流：和被编译的语言密切相关（ASCII,Unicode...）
记号流：编译器内部定义的数据结构，编码所识别出的词法单元
如：
if(x>5) 会翻译成 IF LPAREN IDENT(X) GT INT(5) RPAREN
读入i->读入f->读入(，当读入(的时候，这时词法分析器就会根据自身的理解得到IF记号，其它类似；读到"的时候不会把里面的内容一个个单独分析，而是读到后面的"后将整个字符串作为一个整体；行末会有个\n，读到最末尾会有个EOF

语法糖：对复杂行为的封装，方便程序员开发。比如：汇编中一个程序只需要赋值和跳转两个功能就能实现，而C、JAVA等高级语言有各种语法，这些语法就是汇编语法的语法糖；JQuery对JS的语法进行了封装，也是一种语法糖

<!-- 语法分析 -->
将词法分析后得到的记号流进一步进行语法分析，输出一个抽象语法树
当发现有语法问题的时候会给出比较明确的错误提示，当没有语法问题的时候构建语法树（各种算法，简直不能再复杂+_+）
源代码：
if(x>5)
    y="hello";
else
    z=1;
语法树：
            if
    >       =            =
  x  5    y   "hello"   z  1

<!-- 语义分析 -->
将抽象语法树生成为目标代码或中间表示；目标代码就是能运行的二进制代码，中间表示就是还需要进行分析的代码，现代编译器通常会生成中间表示继续分析
抽象语法树—>翻译1—>中间表示1—>翻译2—>中间表示2—>翻译3—>中间表示3—>翻译4—>目标代码；其中中间表示进行翻译可能有n个，每次翻译的作用不同，具体因编译器而异；中间表示主要有三地址码、控制流图、数据流分析、到达定义分析、活性分析等
语义分析主要内容包括：变量在使用前先进行声明，每个表达式都有合适的类型，函数调用和函数的定义一致等等
在语义分析中发现错误，编译器则报错
大部分程序语言都采用自然语言来表达程序语言的语义，如：对于+运算，要求左右操作数都必须是数字类型

<!-- 代码优化 -->
主要在中间表示中进行优化，不是所有中间表示都会进行代码优化，会根据当前中间表示是否适合优化来决定是否进行代码优化
优化的目的：更小、更快、更节能、cache行为更好等等；但不存在彻底的优化（完全优化）

<!-- 代码生成 -->
负责把源程序翻译成目标机器上的代码：包括给源程序的数据分配计算资源；给源程序的代码选择指令
给数据分配计算资源：
1、源程序的数据：全局变量、局部变量、动态分配等
2、机器计算资源：寄存器、数据区、代码区、栈取、堆区
如何合理的分配就是需要考虑的问题，如：变量放在内存里还是寄存器里