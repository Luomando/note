编译器核心功能：
源代码（C,Java等）—>编译器（静态计算：只翻译不执行）—>目标程序（x86,bytecode等：不同语言的源代码生产的目标代码也不同，最后生成一个可执行程序即目标程序）—>计算机（PC,JVM等：对目标程序进行动态运算并执行）—>结果
解释器：
源代码—>解释器—>结果（不会生成可执行程序，直接输出结果）

模块化：编译器内部具有非常模块化的高层结构，从而简化编译器的开发，在编译过程中具有多个阶段组成的流水线模式
前端模块：将输入部分作为一个模块，又可以更细分为词法分析模块、语法分析模块等
后端模块：将输出部分作为一个模块，又可以更细分为指令生成模块、指令优化模块等
一种没有优化的编译器结构：
源代码（字符序列）—>词法分析（记号序列）—>语法分析（抽象语法树）—>语义分析（中间代码）—>代码生成（目标代码）

指令：代码在CPU上运行会先通过编译等翻译为一条条的指令，CPU的运行速度越高，每秒运行的指令也就越多，通常的计算机CPU能达到上亿条指令每秒的运算速度

简单的编译例子：
源代码：1+2+3
通过词法语法分析得到二叉树结构：
    +
  +   3
1   2
以后续遍历（从下往上）的方式进行编译，使用编译指令push和add：
push(1)->push(2)->push(+)：当push到add(+)指令的时候就会从栈中取出两个数进行相加1+2得到3，然后push(3)到栈中，继续编译
push(3)->push(+)：再次读到add指令，又从栈中读取两个数相加3+3得到6，然后push(6)，编译完毕。
这个例子编译完毕后，就是一个6
*由此就可以看出编译和解释的性能差距，编译后的程序在运行的时候就直接运行6；而解释器就是将源代码1+2+3来运行

<!-- 词法分析 -->
将源代码作为字符流一个一个字符读入进行分析，然后翻译成自己能理解的语法格式。字符流到记号流的转换。
字符流：和被编译的语言密切相关（ASCII,Unicode...）
记号流：编译器内部定义的数据结构，编码所识别出的词法单元
如：
if(x>5) 会翻译成 IF LPAREN IDENT(X) GT INT(5) RPAREN
读入i->读入f->读入(，当读入(的时候，这时词法分析器就会根据自身的理解得到IF记号，其它类似；读到"的时候不会把里面的内容一个个单独分析，而是读到后面的"后将整个字符串作为一个整体；行末会有个\n，读到最末尾会有个EOF

语法糖：对复杂行为的封装，方便程序员开发。比如：汇编中一个程序只需要赋值和跳转两个功能就能实现，而C、JAVA等高级语言有各种语法，这些语法就是汇编语法的语法糖；JQuery对JS的语法进行了封装，也是一种语法糖

<!-- 语法分析 -->
